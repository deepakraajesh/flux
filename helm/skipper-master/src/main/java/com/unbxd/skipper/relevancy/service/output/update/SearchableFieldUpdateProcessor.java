package com.unbxd.skipper.relevancy.service.output.update;

import com.amazonaws.services.kendra.model.Search;
import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.inject.Inject;
import com.unbxd.console.model.*;
import com.unbxd.field.service.FieldService;
import com.unbxd.field.exception.FieldException;
import com.unbxd.field.model.FSSearchableField;
import com.unbxd.field.model.SearchableFieldsResponse;
import com.unbxd.s3.AmazonS3Client;
import com.unbxd.skipper.relevancy.dao.RelevancyDao;
import com.unbxd.skipper.relevancy.expection.RelevancyServiceException;
import com.unbxd.skipper.relevancy.model.*;
import com.unbxd.skipper.relevancy.service.RelevancyOutputUpdateProcessor;
import lombok.extern.log4j.Log4j2;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;


@Log4j2
public class SearchableFieldUpdateProcessor implements RelevancyOutputUpdateProcessor {

    protected RelevancyDao relevancyDao;
    protected FieldService fieldService;
    private static final String RELEVANCY = "relevancy";
    protected AmazonS3Client s3Client;
    protected ObjectMapper mapper = new ObjectMapper();

    @Inject
    public SearchableFieldUpdateProcessor(RelevancyDao relevancyDao,
                                          FieldService fieldService,
                                          AmazonS3Client s3Client) {
        this.relevancyDao = relevancyDao;
        this.fieldService = fieldService;
        this.s3Client = s3Client;
    }

    @Override
    public int update(String siteKey,
                      JobType jobType,
                      ProductType productType) throws RelevancyServiceException {
        return update(siteKey, jobType, productType, Boolean.TRUE);
    }

    protected int update(String siteKey,
                       JobType jobType,
                       ProductType productType, boolean updateToSearch) throws RelevancyServiceException {
        // Pagination over the relevancyDAO
        try {
            RelevancyOutputModel output = relevancyDao.fetchRelevancyOutput(jobType, siteKey);
            if(output == null) {
                String msg = "No searchable fields data generated by the relevancy job";
                log.warn(msg + " for site: "+ siteKey);
                return 0;
            }
            int perPage = 500;
            int count = 0;
            File file = s3Client.downloadFile(output.getS3Location());
            try(JsonParser jParser = new JsonFactory().createParser(file);) {
                if (jParser.nextToken() != JsonToken.START_ARRAY) {
                    String msg = "Illegal json format data stored for facets, There is no array begining of file";
                    throw new RelevancyServiceException(500, msg);
                }
                int index = 0;
                List<SearchableField> searchableFields = new ArrayList<>();
                while (jParser.nextToken() != JsonToken.END_ARRAY) {
                    SearchableField searchableField = mapper.readValue(jParser, SearchableField.class);
                    if(searchableField.getSearchWeightage() != null &&
                            searchableField.getSearchWeightage() != SearchWeightage.NON_SEARCHABLE)
                        count++;
                    index++;
                    searchableFields.add(searchableField);
                    if(index % perPage == 0) {
                        List<FSSearchableField> transformedFieldList = FSSearchableField.transform(searchableFields);
                        if(updateToSearch)
                            fieldService.updateSearchableFields(siteKey, transformedFieldList);
                        relevancyDao.appendData(jobType, siteKey, searchableFields);
                        searchableFields.clear();
                    }
                }
                if(searchableFields.size() > 0) {
                    List<FSSearchableField> transformedFieldList = FSSearchableField.transform(searchableFields);
                    if(updateToSearch)
                        fieldService.updateSearchableFields(siteKey, transformedFieldList);
                    relevancyDao.appendData(jobType, siteKey, searchableFields);
                    searchableFields.clear();
                }
            } catch (IOException e) {
                String msg = "Error while parsing searchable field, reason:" + e.getMessage();
                log.error(msg);
                throw new RelevancyServiceException(500, msg);
            }
            return count;
        } catch (FieldException e){
            log.error("Error while updating the searchable fields for site:" + siteKey + " reason:" +e.getMessage());
            throw new RelevancyServiceException(e.getCode(),e.getMessage());
        }
    }

    @Override
    public void reset(String cookie,
                      String siteKey,
                      JobType jobType,
                      ProductType productType) throws RelevancyServiceException {
        try {
            PageRequest request = buildPageRequest(1,1);
            SearchableFieldsResponse response = fieldService.getSearchableFields(siteKey,request);
            int noOfFields = response.getTotal();
            if(noOfFields == 0) {
               log.error("no searchable fields found in field service for siteKey:"+siteKey);
               return;
            }
            else {
                int pageSize = 500;
                int noOfPages = (noOfFields % pageSize) > 0 ? noOfFields / pageSize + 1 : noOfFields / pageSize;
                for(int page = 1 ; page <= noOfPages; page++ ) {
                    request = buildPageRequest(pageSize, page);
                    response = fieldService.getSearchableFields(siteKey,request);
                    resetSearchableFields(siteKey,response.getSearchableFields());
               }
           }
        } catch (FieldException e) {
            log.error("Error while fetching searchable fields from field service for siteKey:"+ siteKey + " reason:"
                    +e.getMessage());
            throw new RelevancyServiceException(500, "Unable to reset searchable fields");
        }
        update(siteKey, jobType, productType);
    }

    private PageRequest buildPageRequest(int count,
                                         int page) {
        PageRequest request = new PageRequest();
        request.setCount(count);
        request.setPage(page);
        request.setSortBy(RELEVANCY);
        request.setSortOrder(SortOrder.DESCENDING);
        return request;
    }

    private void resetSearchableFields(String siteKey ,
                                       List<FSSearchableField> searchableFields) throws RelevancyServiceException {
        // set searchWeightage of fields to 0 whose searchWeightage is more than 0.
        if(searchableFields.get(0).getSearchWeightage().equals(0))
            return;
        List<FSSearchableField> fieldList = new ArrayList<>(searchableFields.size());
        int index =0;
        while(searchableFields.get(index).getSearchWeightage() > 0 && index < searchableFields.size()) {
            FSSearchableField field = searchableFields.get(index++);
            field.setSearchWeightage(0);
            fieldList.add(field);
        }
        try {
            fieldService.updateSearchableFields(siteKey,fieldList);
        } catch (FieldException e) {
            log.error("Error while reset searchable fields in field service for siteKey:"+siteKey + " reason:"
                    + e.getMessage());
            throw new RelevancyServiceException(500, "Unable to reset searchable fields");
        }
    }


}

